// Code generated by go-swagger; DO NOT EDIT.

package preheat

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the preheat client
type API interface {
	/*
	   CreateInstance creates p2p provider instances

	   Create p2p provider instances*/
	CreateInstance(ctx context.Context, params *CreateInstanceParams) (*CreateInstanceCreated, error)
	/*
	   CreatePolicy creates a preheat policy under a project

	   Create a preheat policy under a project*/
	CreatePolicy(ctx context.Context, params *CreatePolicyParams) (*CreatePolicyCreated, error)
	/*
	   DeleteInstance deletes the specified p2 p provider instance

	   Delete the specified P2P provider instance*/
	DeleteInstance(ctx context.Context, params *DeleteInstanceParams) (*DeleteInstanceOK, error)
	/*
	   DeletePolicy deletes a preheat policy

	   Delete a preheat policy*/
	DeletePolicy(ctx context.Context, params *DeletePolicyParams) (*DeletePolicyOK, error)
	/*
	   GetExecution gets a execution detail by id

	   Get a execution detail by id*/
	GetExecution(ctx context.Context, params *GetExecutionParams) (*GetExecutionOK, error)
	/*
	   GetInstance gets a p2 p provider instance

	   Get a P2P provider instance*/
	GetInstance(ctx context.Context, params *GetInstanceParams) (*GetInstanceOK, error)
	/*
	   GetPolicy gets a preheat policy

	   Get a preheat policy*/
	GetPolicy(ctx context.Context, params *GetPolicyParams) (*GetPolicyOK, error)
	/*
	   GetPreheatLog gets the log text stream of the specified task for the given execution

	   Get the log text stream of the specified task for the given execution*/
	GetPreheatLog(ctx context.Context, params *GetPreheatLogParams) (*GetPreheatLogOK, error)
	/*
	   ListExecutions lists executions for the given policy

	   List executions for the given policy*/
	ListExecutions(ctx context.Context, params *ListExecutionsParams) (*ListExecutionsOK, error)
	/*
	   ListInstances lists p2 p provider instances

	   List P2P provider instances*/
	ListInstances(ctx context.Context, params *ListInstancesParams) (*ListInstancesOK, error)
	/*
	   ListPolicies lists preheat policies

	   List preheat policies*/
	ListPolicies(ctx context.Context, params *ListPoliciesParams) (*ListPoliciesOK, error)
	/*
	   ListProviders lists p2 p providers

	   List P2P providers*/
	ListProviders(ctx context.Context, params *ListProvidersParams) (*ListProvidersOK, error)
	/*
	   ListProvidersUnderProject gets all providers at project level

	   Get all providers at project level*/
	ListProvidersUnderProject(ctx context.Context, params *ListProvidersUnderProjectParams) (*ListProvidersUnderProjectOK, error)
	/*
	   ListTasks lists all the related tasks for the given execution

	   List all the related tasks for the given execution*/
	ListTasks(ctx context.Context, params *ListTasksParams) (*ListTasksOK, error)
	/*
	   ManualPreheat manuals preheat

	   Manual preheat*/
	ManualPreheat(ctx context.Context, params *ManualPreheatParams) (*ManualPreheatCreated, error)
	/*
	   PingInstances pings status of a instance

	   This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)
	*/
	PingInstances(ctx context.Context, params *PingInstancesParams) (*PingInstancesOK, error)
	/*
	   StopExecution stops a execution

	   Stop a execution*/
	StopExecution(ctx context.Context, params *StopExecutionParams) (*StopExecutionOK, error)
	/*
	   UpdateInstance updates the specified p2 p provider instance

	   Update the specified P2P provider instance*/
	UpdateInstance(ctx context.Context, params *UpdateInstanceParams) (*UpdateInstanceOK, error)
	/*
	   UpdatePolicy updates preheat policy

	   Update preheat policy*/
	UpdatePolicy(ctx context.Context, params *UpdatePolicyParams) (*UpdatePolicyOK, error)
}

// New creates a new preheat API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for preheat API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreateInstance creates p2p provider instances

Create p2p provider instances
*/
func (a *Client) CreateInstance(ctx context.Context, params *CreateInstanceParams) (*CreateInstanceCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateInstance",
		Method:             "POST",
		PathPattern:        "/p2p/preheat/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreateInstanceCreated:
		return value, nil
	case *CreateInstanceBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateInstanceUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateInstanceForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateInstanceNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateInstanceConflict:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateInstanceInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for CreateInstance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreatePolicy creates a preheat policy under a project

Create a preheat policy under a project
*/
func (a *Client) CreatePolicy(ctx context.Context, params *CreatePolicyParams) (*CreatePolicyCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreatePolicy",
		Method:             "POST",
		PathPattern:        "/projects/{project_name}/preheat/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreatePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreatePolicyCreated:
		return value, nil
	case *CreatePolicyBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePolicyUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePolicyForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePolicyConflict:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreatePolicyInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for CreatePolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteInstance deletes the specified p2 p provider instance

Delete the specified P2P provider instance
*/
func (a *Client) DeleteInstance(ctx context.Context, params *DeleteInstanceParams) (*DeleteInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteInstance",
		Method:             "DELETE",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *DeleteInstanceOK:
		return value, nil
	case *DeleteInstanceUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteInstanceForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteInstanceNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteInstanceInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeleteInstance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePolicy deletes a preheat policy

Delete a preheat policy
*/
func (a *Client) DeletePolicy(ctx context.Context, params *DeletePolicyParams) (*DeletePolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeletePolicy",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeletePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *DeletePolicyOK:
		return value, nil
	case *DeletePolicyBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeletePolicyUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeletePolicyForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeletePolicyNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeletePolicyInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for DeletePolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetExecution gets a execution detail by id

Get a execution detail by id
*/
func (a *Client) GetExecution(ctx context.Context, params *GetExecutionParams) (*GetExecutionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetExecution",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetExecutionOK:
		return value, nil
	case *GetExecutionBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetExecutionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetExecutionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetExecutionNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetExecutionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetExecution: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetInstance gets a p2 p provider instance

Get a P2P provider instance
*/
func (a *Client) GetInstance(ctx context.Context, params *GetInstanceParams) (*GetInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetInstance",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetInstanceOK:
		return value, nil
	case *GetInstanceBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetInstanceUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetInstanceForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetInstanceNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetInstanceInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetInstance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPolicy gets a preheat policy

Get a preheat policy
*/
func (a *Client) GetPolicy(ctx context.Context, params *GetPolicyParams) (*GetPolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPolicy",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPolicyOK:
		return value, nil
	case *GetPolicyBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPolicyUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPolicyForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPolicyNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPolicyInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetPolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPreheatLog gets the log text stream of the specified task for the given execution

Get the log text stream of the specified task for the given execution
*/
func (a *Client) GetPreheatLog(ctx context.Context, params *GetPreheatLogParams) (*GetPreheatLogOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPreheatLog",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPreheatLogReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetPreheatLogOK:
		return value, nil
	case *GetPreheatLogBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPreheatLogUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPreheatLogForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPreheatLogNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetPreheatLogInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetPreheatLog: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListExecutions lists executions for the given policy

List executions for the given policy
*/
func (a *Client) ListExecutions(ctx context.Context, params *ListExecutionsParams) (*ListExecutionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListExecutions",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListExecutionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListExecutionsOK:
		return value, nil
	case *ListExecutionsBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListExecutionsUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListExecutionsForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListExecutionsNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListExecutionsInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListExecutions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListInstances lists p2 p provider instances

List P2P provider instances
*/
func (a *Client) ListInstances(ctx context.Context, params *ListInstancesParams) (*ListInstancesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListInstances",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListInstancesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListInstancesOK:
		return value, nil
	case *ListInstancesBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListInstancesUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListInstancesForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListInstancesNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListInstancesInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListInstances: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListPolicies lists preheat policies

List preheat policies
*/
func (a *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams) (*ListPoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListPolicies",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListPoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListPoliciesOK:
		return value, nil
	case *ListPoliciesBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListPoliciesUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListPoliciesForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListPoliciesInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListPolicies: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProviders lists p2 p providers

List P2P providers
*/
func (a *Client) ListProviders(ctx context.Context, params *ListProvidersParams) (*ListProvidersOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListProviders",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/providers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProvidersReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListProvidersOK:
		return value, nil
	case *ListProvidersBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListProviders: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProvidersUnderProject gets all providers at project level

Get all providers at project level
*/
func (a *Client) ListProvidersUnderProject(ctx context.Context, params *ListProvidersUnderProjectParams) (*ListProvidersUnderProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListProvidersUnderProject",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/providers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProvidersUnderProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListProvidersUnderProjectOK:
		return value, nil
	case *ListProvidersUnderProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersUnderProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersUnderProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersUnderProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProvidersUnderProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListProvidersUnderProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListTasks lists all the related tasks for the given execution

List all the related tasks for the given execution
*/
func (a *Client) ListTasks(ctx context.Context, params *ListTasksParams) (*ListTasksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListTasks",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListTasksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListTasksOK:
		return value, nil
	case *ListTasksBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListTasksUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListTasksForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListTasksNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListTasksInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ListTasks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ManualPreheat manuals preheat

Manual preheat
*/
func (a *Client) ManualPreheat(ctx context.Context, params *ManualPreheatParams) (*ManualPreheatCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ManualPreheat",
		Method:             "POST",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ManualPreheatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ManualPreheatCreated:
		return value, nil
	case *ManualPreheatBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ManualPreheatUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ManualPreheatForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ManualPreheatNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ManualPreheatInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ManualPreheat: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PingInstances pings status of a instance

This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)
*/
func (a *Client) PingInstances(ctx context.Context, params *PingInstancesParams) (*PingInstancesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PingInstances",
		Method:             "POST",
		PathPattern:        "/p2p/preheat/instances/ping",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PingInstancesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *PingInstancesOK:
		return value, nil
	case *PingInstancesBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingInstancesUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingInstancesNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingInstancesInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PingInstances: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopExecution stops a execution

Stop a execution
*/
func (a *Client) StopExecution(ctx context.Context, params *StopExecutionParams) (*StopExecutionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StopExecution",
		Method:             "PATCH",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *StopExecutionOK:
		return value, nil
	case *StopExecutionBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopExecutionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopExecutionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopExecutionNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *StopExecutionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for StopExecution: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateInstance updates the specified p2 p provider instance

Update the specified P2P provider instance
*/
func (a *Client) UpdateInstance(ctx context.Context, params *UpdateInstanceParams) (*UpdateInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateInstance",
		Method:             "PUT",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdateInstanceOK:
		return value, nil
	case *UpdateInstanceBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateInstanceUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateInstanceForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateInstanceNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateInstanceInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdateInstance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdatePolicy updates preheat policy

Update preheat policy
*/
func (a *Client) UpdatePolicy(ctx context.Context, params *UpdatePolicyParams) (*UpdatePolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdatePolicy",
		Method:             "PUT",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdatePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdatePolicyOK:
		return value, nil
	case *UpdatePolicyBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePolicyUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePolicyForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePolicyNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePolicyConflict:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdatePolicyInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for UpdatePolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
