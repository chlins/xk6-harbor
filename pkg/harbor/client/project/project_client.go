// Code generated by go-swagger; DO NOT EDIT.

package project

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the project client
type API interface {
	/*
	   CreateProject creates a new project

	   This endpoint is for user to create a new project.*/
	CreateProject(ctx context.Context, params *CreateProjectParams) (*CreateProjectCreated, error)
	/*
	   DeleteProject deletes project by project ID

	   This endpoint is aimed to delete project by project ID.*/
	DeleteProject(ctx context.Context, params *DeleteProjectParams) (*DeleteProjectOK, error)
	/*
	   GetLogs gets recent logs of the projects

	   Get recent logs of the projects*/
	GetLogs(ctx context.Context, params *GetLogsParams) (*GetLogsOK, error)
	/*
	   GetProject returns specific project detail information

	   This endpoint returns specific project information by project ID.*/
	GetProject(ctx context.Context, params *GetProjectParams) (*GetProjectOK, error)
	/*
	   GetProjectDeletable gets the deletable status of the project

	   Get the deletable status of the project*/
	GetProjectDeletable(ctx context.Context, params *GetProjectDeletableParams) (*GetProjectDeletableOK, error)
	/*
	   GetProjectSummary gets summary of the project

	   Get summary of the project.*/
	GetProjectSummary(ctx context.Context, params *GetProjectSummaryParams) (*GetProjectSummaryOK, error)
	/*
	   GetScannerOfProject gets project level scanner

	   Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.*/
	GetScannerOfProject(ctx context.Context, params *GetScannerOfProjectParams) (*GetScannerOfProjectOK, error)
	/*
	   HeadProject checks if the project name user provided already exists

	   This endpoint is used to check if the project name provided already exist.*/
	HeadProject(ctx context.Context, params *HeadProjectParams) (*HeadProjectOK, error)
	/*
	   ListProjects lists projects

	   This endpoint returns projects created by Harbor.*/
	ListProjects(ctx context.Context, params *ListProjectsParams) (*ListProjectsOK, error)
	/*
	   ListScannerCandidatesOfProject gets scanner registration candidates for configurating project level scanner

	   Retrieve the system configured scanner registrations as candidates of setting project level scanner.*/
	ListScannerCandidatesOfProject(ctx context.Context, params *ListScannerCandidatesOfProjectParams) (*ListScannerCandidatesOfProjectOK, error)
	/*
	   SetScannerOfProject configures scanner for the specified project

	   Set one of the system configured scanner registration as the indepndent scanner of the specified project.*/
	SetScannerOfProject(ctx context.Context, params *SetScannerOfProjectParams) (*SetScannerOfProjectOK, error)
	/*
	   UpdateProject updates properties for a selected project

	   This endpoint is aimed to update the properties of a project.*/
	UpdateProject(ctx context.Context, params *UpdateProjectParams) (*UpdateProjectOK, error)
}

// New creates a new project API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for project API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreateProject creates a new project

This endpoint is for user to create a new project.
*/
func (a *Client) CreateProject(ctx context.Context, params *CreateProjectParams) (*CreateProjectCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createProject",
		Method:             "POST",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreateProjectCreated:
		return value, nil
	case *CreateProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateProjectConflict:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteProject deletes project by project ID

This endpoint is aimed to delete project by project ID.
*/
func (a *Client) DeleteProject(ctx context.Context, params *DeleteProjectParams) (*DeleteProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteProject",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_name_or_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *DeleteProjectOK:
		return value, nil
	case *DeleteProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteProjectPreconditionFailed:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLogs gets recent logs of the projects

Get recent logs of the projects
*/
func (a *Client) GetLogs(ctx context.Context, params *GetLogsParams) (*GetLogsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLogs",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLogsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetLogsOK:
		return value, nil
	case *GetLogsBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetLogsUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetLogsInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProject returns specific project detail information

This endpoint returns specific project information by project ID.
*/
func (a *Client) GetProject(ctx context.Context, params *GetProjectParams) (*GetProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getProject",
		Method:             "GET",
		PathPattern:        "/projects/{project_name_or_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetProjectOK:
		return value, nil
	case *GetProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectDeletable gets the deletable status of the project

Get the deletable status of the project
*/
func (a *Client) GetProjectDeletable(ctx context.Context, params *GetProjectDeletableParams) (*GetProjectDeletableOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getProjectDeletable",
		Method:             "GET",
		PathPattern:        "/projects/{project_name_or_id}/_deletable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectDeletableReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetProjectDeletableOK:
		return value, nil
	case *GetProjectDeletableUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectDeletableForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectDeletableNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectDeletableInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectDeletable: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectSummary gets summary of the project

Get summary of the project.
*/
func (a *Client) GetProjectSummary(ctx context.Context, params *GetProjectSummaryParams) (*GetProjectSummaryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getProjectSummary",
		Method:             "GET",
		PathPattern:        "/projects/{project_name_or_id}/summary",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectSummaryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetProjectSummaryOK:
		return value, nil
	case *GetProjectSummaryBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectSummaryUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectSummaryForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectSummaryNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetProjectSummaryInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectSummary: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetScannerOfProject gets project level scanner

Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.
*/
func (a *Client) GetScannerOfProject(ctx context.Context, params *GetScannerOfProjectParams) (*GetScannerOfProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getScannerOfProject",
		Method:             "GET",
		PathPattern:        "/projects/{project_name_or_id}/scanner",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetScannerOfProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetScannerOfProjectOK:
		return value, nil
	case *GetScannerOfProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetScannerOfProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetScannerOfProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetScannerOfProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetScannerOfProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getScannerOfProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeadProject checks if the project name user provided already exists

This endpoint is used to check if the project name provided already exist.
*/
func (a *Client) HeadProject(ctx context.Context, params *HeadProjectParams) (*HeadProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "headProject",
		Method:             "HEAD",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeadProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *HeadProjectOK:
		return value, nil
	case *HeadProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *HeadProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProjects lists projects

This endpoint returns projects created by Harbor.
*/
func (a *Client) ListProjects(ctx context.Context, params *ListProjectsParams) (*ListProjectsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listProjects",
		Method:             "GET",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProjectsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListProjectsOK:
		return value, nil
	case *ListProjectsUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListProjectsInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listProjects: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListScannerCandidatesOfProject gets scanner registration candidates for configurating project level scanner

Retrieve the system configured scanner registrations as candidates of setting project level scanner.
*/
func (a *Client) ListScannerCandidatesOfProject(ctx context.Context, params *ListScannerCandidatesOfProjectParams) (*ListScannerCandidatesOfProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listScannerCandidatesOfProject",
		Method:             "GET",
		PathPattern:        "/projects/{project_name_or_id}/scanner/candidates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListScannerCandidatesOfProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListScannerCandidatesOfProjectOK:
		return value, nil
	case *ListScannerCandidatesOfProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListScannerCandidatesOfProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListScannerCandidatesOfProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListScannerCandidatesOfProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listScannerCandidatesOfProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SetScannerOfProject configures scanner for the specified project

Set one of the system configured scanner registration as the indepndent scanner of the specified project.
*/
func (a *Client) SetScannerOfProject(ctx context.Context, params *SetScannerOfProjectParams) (*SetScannerOfProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setScannerOfProject",
		Method:             "PUT",
		PathPattern:        "/projects/{project_name_or_id}/scanner",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SetScannerOfProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *SetScannerOfProjectOK:
		return value, nil
	case *SetScannerOfProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SetScannerOfProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SetScannerOfProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SetScannerOfProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SetScannerOfProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setScannerOfProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateProject updates properties for a selected project

This endpoint is aimed to update the properties of a project.
*/
func (a *Client) UpdateProject(ctx context.Context, params *UpdateProjectParams) (*UpdateProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateProject",
		Method:             "PUT",
		PathPattern:        "/projects/{project_name_or_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdateProjectOK:
		return value, nil
	case *UpdateProjectBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateProjectUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateProjectForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateProjectNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateProjectInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
