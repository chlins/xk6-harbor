// Code generated by go-swagger; DO NOT EDIT.

package retention

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the retention client
type API interface {
	/*
	   CreateRetention creates retention policy

	   Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.*/
	CreateRetention(ctx context.Context, params *CreateRetentionParams) (*CreateRetentionCreated, error)
	/*
	   DeleteRetention deletes retention policy

	   Delete Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.*/
	DeleteRetention(ctx context.Context, params *DeleteRetentionParams) (*DeleteRetentionOK, error)
	/*
	   GetRentenitionMetadata gets retention metadatas

	   Get Retention Metadatas.*/
	GetRentenitionMetadata(ctx context.Context, params *GetRentenitionMetadataParams) (*GetRentenitionMetadataOK, error)
	/*
	   GetRetention gets retention policy

	   Get Retention Policy.*/
	GetRetention(ctx context.Context, params *GetRetentionParams) (*GetRetentionOK, error)
	/*
	   GetRetentionTaskLog gets retention job task log

	   Get Retention job task log, tags ratain or deletion detail will be shown in a table.*/
	GetRetentionTaskLog(ctx context.Context, params *GetRetentionTaskLogParams) (*GetRetentionTaskLogOK, error)
	/*
	   ListRetentionExecutions gets retention executions

	   Get Retention executions, execution status may be delayed before job service schedule it up.*/
	ListRetentionExecutions(ctx context.Context, params *ListRetentionExecutionsParams) (*ListRetentionExecutionsOK, error)
	/*
	   ListRetentionTasks gets retention tasks

	   Get Retention tasks, each repository as a task.*/
	ListRetentionTasks(ctx context.Context, params *ListRetentionTasksParams) (*ListRetentionTasksOK, error)
	/*
	   OperateRetentionExecution stops a retention execution

	   Stop a Retention execution, only support "stop" action now.*/
	OperateRetentionExecution(ctx context.Context, params *OperateRetentionExecutionParams) (*OperateRetentionExecutionOK, error)
	/*
	   TriggerRetentionExecution triggers a retention execution

	   Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.*/
	TriggerRetentionExecution(ctx context.Context, params *TriggerRetentionExecutionParams) (*TriggerRetentionExecutionOK, *TriggerRetentionExecutionCreated, error)
	/*
	   UpdateRetention updates retention policy

	   Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.*/
	UpdateRetention(ctx context.Context, params *UpdateRetentionParams) (*UpdateRetentionOK, error)
}

// New creates a new retention API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for retention API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreateRetention creates retention policy

Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.
*/
func (a *Client) CreateRetention(ctx context.Context, params *CreateRetentionParams) (*CreateRetentionCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createRetention",
		Method:             "POST",
		PathPattern:        "/retentions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRetentionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *CreateRetentionCreated:
		return value, nil
	case *CreateRetentionBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateRetentionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateRetentionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *CreateRetentionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createRetention: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteRetention deletes retention policy

Delete Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.
*/
func (a *Client) DeleteRetention(ctx context.Context, params *DeleteRetentionParams) (*DeleteRetentionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRetention",
		Method:             "DELETE",
		PathPattern:        "/retentions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRetentionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *DeleteRetentionOK:
		return value, nil
	case *DeleteRetentionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteRetentionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *DeleteRetentionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteRetention: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRentenitionMetadata gets retention metadatas

Get Retention Metadatas.
*/
func (a *Client) GetRentenitionMetadata(ctx context.Context, params *GetRentenitionMetadataParams) (*GetRentenitionMetadataOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRentenitionMetadata",
		Method:             "GET",
		PathPattern:        "/retentions/metadatas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRentenitionMetadataReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetRentenitionMetadataOK:
		return value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRentenitionMetadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRetention gets retention policy

Get Retention Policy.
*/
func (a *Client) GetRetention(ctx context.Context, params *GetRetentionParams) (*GetRetentionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRetention",
		Method:             "GET",
		PathPattern:        "/retentions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRetentionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetRetentionOK:
		return value, nil
	case *GetRetentionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetRetentionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetRetentionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRetention: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetRetentionTaskLog gets retention job task log

Get Retention job task log, tags ratain or deletion detail will be shown in a table.
*/
func (a *Client) GetRetentionTaskLog(ctx context.Context, params *GetRetentionTaskLogParams) (*GetRetentionTaskLogOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRetentionTaskLog",
		Method:             "GET",
		PathPattern:        "/retentions/{id}/executions/{eid}/tasks/{tid}",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRetentionTaskLogReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *GetRetentionTaskLogOK:
		return value, nil
	case *GetRetentionTaskLogUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetRetentionTaskLogForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *GetRetentionTaskLogInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getRetentionTaskLog: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListRetentionExecutions gets retention executions

Get Retention executions, execution status may be delayed before job service schedule it up.
*/
func (a *Client) ListRetentionExecutions(ctx context.Context, params *ListRetentionExecutionsParams) (*ListRetentionExecutionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listRetentionExecutions",
		Method:             "GET",
		PathPattern:        "/retentions/{id}/executions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListRetentionExecutionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListRetentionExecutionsOK:
		return value, nil
	case *ListRetentionExecutionsUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListRetentionExecutionsForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListRetentionExecutionsInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listRetentionExecutions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListRetentionTasks gets retention tasks

Get Retention tasks, each repository as a task.
*/
func (a *Client) ListRetentionTasks(ctx context.Context, params *ListRetentionTasksParams) (*ListRetentionTasksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listRetentionTasks",
		Method:             "GET",
		PathPattern:        "/retentions/{id}/executions/{eid}/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListRetentionTasksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ListRetentionTasksOK:
		return value, nil
	case *ListRetentionTasksUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListRetentionTasksForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ListRetentionTasksInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listRetentionTasks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
OperateRetentionExecution stops a retention execution

Stop a Retention execution, only support "stop" action now.
*/
func (a *Client) OperateRetentionExecution(ctx context.Context, params *OperateRetentionExecutionParams) (*OperateRetentionExecutionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "operateRetentionExecution",
		Method:             "PATCH",
		PathPattern:        "/retentions/{id}/executions/{eid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &OperateRetentionExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *OperateRetentionExecutionOK:
		return value, nil
	case *OperateRetentionExecutionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *OperateRetentionExecutionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *OperateRetentionExecutionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for operateRetentionExecution: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TriggerRetentionExecution triggers a retention execution

Trigger a Retention Execution, if dry_run is True, nothing would be deleted actually.
*/
func (a *Client) TriggerRetentionExecution(ctx context.Context, params *TriggerRetentionExecutionParams) (*TriggerRetentionExecutionOK, *TriggerRetentionExecutionCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "triggerRetentionExecution",
		Method:             "POST",
		PathPattern:        "/retentions/{id}/executions",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TriggerRetentionExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *TriggerRetentionExecutionOK:
		return value, nil, nil
	case *TriggerRetentionExecutionCreated:
		return nil, value, nil
	case *TriggerRetentionExecutionUnauthorized:
		return nil, nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *TriggerRetentionExecutionForbidden:
		return nil, nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *TriggerRetentionExecutionInternalServerError:
		return nil, nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for triggerRetentionExecution: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateRetention updates retention policy

Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.
*/
func (a *Client) UpdateRetention(ctx context.Context, params *UpdateRetentionParams) (*UpdateRetentionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateRetention",
		Method:             "PUT",
		PathPattern:        "/retentions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRetentionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *UpdateRetentionOK:
		return value, nil
	case *UpdateRetentionUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateRetentionForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *UpdateRetentionInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateRetention: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
