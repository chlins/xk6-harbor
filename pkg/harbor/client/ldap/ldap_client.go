// Code generated by go-swagger; DO NOT EDIT.

package ldap

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the ldap client
type API interface {
	/*
	   ImportLdapUser imports selected available ldap users

	   This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information. If have errors when import user, will return the list of importing failed uid and the failed reason.
	*/
	ImportLdapUser(ctx context.Context, params *ImportLdapUserParams) (*ImportLdapUserOK, error)
	/*
	   PingLdap pings available ldap service

	   This endpoint ping the available ldap service for test related configuration parameters.
	*/
	PingLdap(ctx context.Context, params *PingLdapParams) (*PingLdapOK, error)
	/*
	   SearchLdapGroup searches available ldap groups

	   This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.
	*/
	SearchLdapGroup(ctx context.Context, params *SearchLdapGroupParams) (*SearchLdapGroupOK, error)
	/*
	   SearchLdapUser searches available ldap users

	   This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.
	*/
	SearchLdapUser(ctx context.Context, params *SearchLdapUserParams) (*SearchLdapUserOK, error)
}

// New creates a new ldap API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for ldap API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
ImportLdapUser imports selected available ldap users

This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information. If have errors when import user, will return the list of importing failed uid and the failed reason.
*/
func (a *Client) ImportLdapUser(ctx context.Context, params *ImportLdapUserParams) (*ImportLdapUserOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "importLdapUser",
		Method:             "POST",
		PathPattern:        "/ldap/users/import",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImportLdapUserReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *ImportLdapUserOK:
		return value, nil
	case *ImportLdapUserBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ImportLdapUserUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ImportLdapUserForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ImportLdapUserNotFound:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *ImportLdapUserInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importLdapUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PingLdap pings available ldap service

This endpoint ping the available ldap service for test related configuration parameters.
*/
func (a *Client) PingLdap(ctx context.Context, params *PingLdapParams) (*PingLdapOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "pingLdap",
		Method:             "POST",
		PathPattern:        "/ldap/ping",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PingLdapReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *PingLdapOK:
		return value, nil
	case *PingLdapBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingLdapUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingLdapForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *PingLdapInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pingLdap: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SearchLdapGroup searches available ldap groups

This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.
*/
func (a *Client) SearchLdapGroup(ctx context.Context, params *SearchLdapGroupParams) (*SearchLdapGroupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "searchLdapGroup",
		Method:             "GET",
		PathPattern:        "/ldap/groups/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SearchLdapGroupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *SearchLdapGroupOK:
		return value, nil
	case *SearchLdapGroupBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapGroupUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapGroupForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapGroupInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for searchLdapGroup: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SearchLdapUser searches available ldap users

This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.
*/
func (a *Client) SearchLdapUser(ctx context.Context, params *SearchLdapUserParams) (*SearchLdapUserOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "searchLdapUser",
		Method:             "GET",
		PathPattern:        "/ldap/users/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SearchLdapUserReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *SearchLdapUserOK:
		return value, nil
	case *SearchLdapUserBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapUserUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapUserForbidden:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *SearchLdapUserInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for searchLdapUser: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
